from idautils import *
from idc import *
import idaapi
import idautils
import idc
import bnrev
import bnrev.algorithms
import bnrev.calculate as calculate
import bnrev.symbolic as symbolic

blocks = [(0xb94c78, 264, 'decrypt_and_expand'), (0x134c78,264, 'decrypt_and_expand_2')]

def comment_all_blocks():
  '''requires my specific address space'''
  for i in blocks:
    for j in range(i[1]):
      comment_encBlock(i[0] + (j*8))

def get_drefs(addr):
  rv = []
  cur = idaapi.get_first_dref_to(addr)
  while cur != idaapi.BADADDR:
    rv.append(cur)
    cur = idaapi.get_next_dref_to(addr, cur)
  return rv

def _delete_deobf_drefs():
  for b in blocks:
    for i in range(b[1]):
      addr = b[0] + (i*8)
      derefs = get_drefs(addr)
      for d in derefs:
        idaapi.del_dref(d, addr)

def _tag_decryptor_calls(decryptor_func='decrypt_and_expand', encBlockArray=0xb94c78):
  faddr = idc.LocByName(decryptor_func) if type(decryptor_func) == type('str') else decryptor_func
  seen = set()

  for xref in idautils.CodeRefsTo(faddr, 0):

    if xref in seen:
      continue
    seen.add(xref)

    print 'trying to xref to call @0x%x' % (xref)
    fg = bnrev.FunctionGraph(xref)
    for i in fg.nodes[xref].incoming:
      try:
        print 'trying to find eax for call to %s @ 0x%x' % (decryptor_func, i)
        arg = calculate.calc(i, fg)[bnrev.eax]

        if not isinstance(arg, symbolic.Number):
          print 'found a non number: %s' % (arg,)
          continue
        else:
          addr = encBlockArray + (8 * int(arg.n))
          print 'adding dref 0x%x -> 0x%x' % (i, addr)
          idaapi.add_dref(i, addr, idaapi.dr_I)
      except:
        pass

def tag_decryptor_calls():
  for i in blocks:
    _tag_decryptor_calls(i[2], i[0])

#    for nstack in fg.stackwalk(xref, direction='incoming'):
#      n = nstack[-1]
#
#      if idc.GetMnem(n) != 'push':
#        continue
#
#      isseen = seen.intersection(nstack)
#      if isseen:
#        continue
#      else:
#        seen.add(n)
#
#      print 'found push @0x%x' % (n)
#      if idc.GetOpType(n,0) != idc.o_imm:
#        print 'Cannot get the operand for 0x%x' % (n)
#      else:
#        imm = idc.GetOpnd(n,0)
#        try:
#          imm = int(imm[:-1],16)
#          addr = encBlockArray + (8 * imm)
#          print 'adding data xref %x -> %x' % (n, addr)
#          idaapi.add_dref(n, addr, idaapi.dr_I)
#        except:
#          print 'failured parsing %s' % (imm)

def comment_encBlock(dataDescAddr):
  _key = Byte(dataDescAddr)
  _len = Word(dataDescAddr+2)
  _ptr = Dword(dataDescAddr+4)
  unencrypted = []

  for i in range(_len):
    c = Byte(_ptr+i)
    c ^= _key
    c ^= i
    c &= 0xff
    unencrypted.append(chr(c))

  unencrypted = ''.join(unencrypted)
  MakeRptCmt(dataDescAddr, "[decrypt] %s" % (unencrypted,))
  return unencrypted
