from idautils import *
from idc import *
import idaapi
import idautils
import idc
import bnrev
import bnrev.algorithms

def comment_all_blocks():
  '''requires my specific address space'''
  blocks = [(0xb94c78, 264)]

  for i in blocks:
    for j in range(i[1]):
      comment_encBlock(i[0] + (j*8))

def tag_decryptor_calls(decryptor_func='decrypt_and_expand', encBlockArray=0xb94c78):
  faddr = idc.LocByName(decryptor_func) if type(decryptor_func) == type('str') else decryptor_func
  seen = set()

  for xref in idautils.CodeRefsTo(faddr, 0):
    print 'trying to xref to call @0x%x' % (xref)
    fg = bnrev.FunctionGraph(xref)
    for nstack in fg.stackwalk(xref, direction='incoming'):
      n = nstack[-1]

      if idc.GetMnem(n) != 'push':
        continue

      isseen = seen.intersection(nstack)
      if isseen:
        continue
      else:
        seen.add(n)

      print 'found push @0x%x' % (n)
      if idc.GetOpType(n,0) != idc.o_imm:
        print 'Cannot get the operand for 0x%x' % (n)
      else:
        imm = idc.GetOpnd(n,0)
        try:
          imm = int(imm[:-1],16)
          addr = encBlockArray + (8 * imm)
          print 'adding data xref %x -> %x' % (n, addr)
          idaapi.add_dref(n, addr, idaapi.dr_I)
        except:
          print 'failured parsing %s' % (imm)

def comment_encBlock(dataDescAddr):
  _key = Byte(dataDescAddr)
  _len = Word(dataDescAddr+2)
  _ptr = Dword(dataDescAddr+4)
  unencrypted = []

  for i in range(_len):
    c = Byte(_ptr+i)
    c ^= _key
    c ^= i
    c &= 0xff
    unencrypted.append(chr(c))

  unencrypted = ''.join(unencrypted)
  MakeRptCmt(dataDescAddr, "[decrypt] %s" % (unencrypted,))
  return unencrypted
