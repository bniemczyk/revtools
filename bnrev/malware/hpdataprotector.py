import bnrev
import bnrev.memoize
import bnrev.idafun
from bnrev.algorithms import pathQ
from symath import *
import idaapi
import idc

cg = bnrev.CallGraph()
print '_swprintf: %s' % (pathQ(cg, 0x40eab0, '_swprintf'))

def get_switch_addresses(tableaddr=0x413c28, length=0x66):
  for i in range(length):
    yield idc.Dword(tableaddr + (i * 4))

def relabel_opcodes():
  addrs = list(get_switch_addresses())
  for i in range(len(addrs)):
    idc.MakeNameEx(addrs[i], '_opcode_0x%x' % (i), idc.SN_LOCAL)

def look_for_swprintf():
  addrs = list(get_switch_addresses())
  fg = bnrev.FunctionGraph(addrs[0])

  paths = {}

  with bnrev.memoize.m(bnrev, 'calc'):
    for _addr in range(len(addrs)):
      addr = addrs[_addr]
      for n,l in fg.walk(addr):
#        try:
          if n != addr and n in addrs:
            break
          i = bnrev.idafun.decode(n)
          if i == None:
            continue

          if i.mnemonic.lower() == 'call':
            #if i.operands[0].type == 'Immediate':
            #  if pathQ(cg, i.value, '_swprintf'):
            #    print '0x%x (opcode 0x%x) calls _swprintf' % (addr, _addr)
            if i.operands[0].type == 'AbsoluteMemoryAddress' and idc.Name(i.operands[0].disp) == '_swprintf':
              inc = fg.nodes[i.address].incoming
              for inc in fg.nodes[i.address].incoming:

                cur = bnrev.calc(inc)
                a = (bnrev.esp - 4).substitute(cur)
                a = bnrev.DEREF(0x4, a)
                b = (bnrev.esp - 8).substitute(cur)
                b = bnrev.DEREF(0x4, b)

                print '0x%x (opcode 0x%x) calls _swprintf(%s, %s, ...)' % (n, _addr, cur[a] if a in cur else '<unknown>', cur[b] if b in cur else '<unknown>')
#        except:i
#          pass
